---
title: 密码技术调研资料
date: 2020-06-03 23:48:18 +0800
categories: [阅读笔记,crypto]
tags: [crypto] 
comments: true
math: true
pin: true

---



# 1. 概览与介绍

## 1.1 最主要的几种数据加密技术及其作用特性

1. 对称加密…………（机密性—防窃听）
2. 非对称加密………（机密性—防窃听）
3. 单向散列函数……（完整性—防篡改）
4. 消息认证码………（完整性—防篡改，认证—防伪装）
5. 数字签名…………（完整性—防篡改，认证—防伪装，不可否认—防否认）
6. 伪随机数生成器…（生成密钥、盐、IV，随机性、不可预测性、不可重复性）




# 2. 对称加密


## 2.1 对称加密概述

对称是指加密和解密用的是同一份密码
加密类型有两种：分组加密和流密码


## 2.2常见对称加密算法原理

- DES 
- 3DES 
- AES 


### 2.2.1 DES

全称 Data Encryption Standard ，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。DES现在已经不是一种安全的加密方法。1999年1月，DES Challenge III中，在22小时15分钟内即公开破解了一个DES密钥。

DES以64bit为一组进行加密，密钥中每7个bit会加上一个奇偶校验位，实际共56bit

DES采用Feistel结构，一共进行16轮

![img]({{ site.url }}/assets/img/source/crypto_1.jpg)


K——子密钥，每一轮都使用不同的子密钥，子密钥通过密钥调度产生，具体算法略

F——轮函数，在Feistel结构中轮函数可以没有反函数  >>>  扩张，与密钥混合，S盒，置换

破解方式：暴力破解（差分分析 ，线性分析）


### 2.2.2 3DES

全称：Triple Data Encryption Algorithm，缩写为TDEA，Triple DEA），或称3DES（Triple DES）

3DES使用“密钥包”，其包含3个DES密钥，K1，K2和K3，均为56位（除去奇偶校验位）。加密算法为：

密文 = EK3(DK2(EK1(明文)))
也就是说，使用K1为密钥进行DES加密，再用K2为密钥进行DES“解密”，最后以K3进行DES加密。

第二步的解密主要是为了与DES兼容

而解密则为其反过程：

明文 = DK1(EK2(DK3(密文)))
即以K3解密，以K2“加密”，最后以K1解密。


安全性：有3个独立密钥的3DES 的密钥长度为168位（三个56位的DES密钥），但由于中途相遇攻击（以空间换时间），它的有效安全性仅为112位。如果为了兼容则会将密钥长度缩短到了112位，但该选项对特定的选择明文攻击和已知明文攻击的强度较弱，因此NIST认定它只有80位的安全性。


### 2.2.3 AES

AES（Advanced Encryption Standard）由美国国家标准与技术研究院（NIST）组织公开竞选后，采用Rijndael算法确定的。2001年11月26日发布，并在2002年5月26日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字命名

Rijndael使用的是代换-置换网络结构（SPN）

加密共有4个步骤：

- 1.SubBytes

这个步骤提供了加密法非线性的变换能力
![img]({{ site.url }}/assets/img/source/crypto_2.jpg)

![img]({{ site.url }}/assets/img/source/crypto_3.jpg)



- 2.ShiftRows

![img]({{ site.url }}/assets/img/source/crypto_4.jpg)


- 3.MixColumns

![img]({{ site.url }}/assets/img/source/crypto_5.jpg)


- 0+4.AddRoundKey

![img]({{ site.url }}/assets/img/source/crypto_6.jpg)



攻击：截至2006年，针对AES唯一的成功攻击是侧信道攻击或社会工程学攻击




## 2.3常见分组加密原理


数据长度不可控，加密的时候一定字节长度分成一组分别加密，按组迭代时的方式就叫分组模式

常见的分组模式有：

**电子密码本（ECB）,密码分组链接（CBC）,密文反馈（CFB）,输出反馈（OFB）,计数器模式（CTR）**



+ 电子密码本（ECB）

![img]({{ site.url }}/assets/img/source/crypto_7.jpg)


缺点：攻击者无需破译就可以操作数据


+ 密码分组链接（CBC）

![img]({{ site.url }}/assets/img/source/crypto_8.jpg)

优点：相互连接，损坏一个分组只会影响该分组和下一个分组，应用：SSL/TLS


+ 密文反馈（CFB）

![img]({{ site.url }}/assets/img/source/crypto_9.jpg)


优点：通过分组加密的方式实现了流密码加密
攻击：重放攻击（replay attack），将当前数据快出错，但替代了后面的数据

+ 输出反馈（OFB）
  
![img]({{ site.url }}/assets/img/source/crypto_10.jpg)

优点：直接反复对密码加密，可以并行


+ 计数器模式（CTR）

![img]({{ site.url }}/assets/img/source/crypto_11.jpg)


 优点：处理流密码，可以并行


推荐使用：CBC，CFB，OFB，CTR



# 3. 非对称加密

## 3.0基本定理

欧拉定理：若$n,a$为正整数，且$n,a$互质，则 $a^{(\varphi(n))}\equiv 1 (mod  n)$

欧拉函数：对正整数$n$，欧拉函数$\varphi(n)$是小于或等于$n$的正整数中与$n$互质的数的数目

模逆元：一整数$a$对同余$n$之模逆元是指满足以下公式的整数$b$ <br>
$a^(-1)\equiv b(mod  n)$ 或 $ab\equiv 1(mod  n)$ <br>
整数$a$对模数$n$之模逆元存在的充分必要条件是$a$和$n$互质

## 3.1 RSA加密算法

公钥加密，私钥解密。主要采用RSA加密算法，名称来自三位发明者姓氏的首字母缩写



- 公钥与私钥的产生

假设Alice想要通过一个不可靠的媒体接收Bob的一条私人消息。她可以用以下的方式来产生一个公钥和一个私钥：

随意选择两个大的素数$p$和$q$, $p$不等于$q$, 计算$N=pq$

根据欧拉函数，求得 $r=\varphi(N)=\varphi(p)\varphi(q)=(p-1)(q-1)$

选择一个小于$r$的整数$e$，使$r$与$e$互质。并求得$e$关于$r$的模逆元，命名为$d$（求$ed\equiv 1 (mod  r)$）。（模逆元存在，当且仅当$e$与$r$互质）将$p$和$q$的记录销毁。此时$(N,e)$是公钥，$(N,d)$是私钥。Alice将她的公钥$(N,e)$传给Bob，而将她的私钥$(N,d)$藏起来。


- 加密消息
    假设Bob想给Alice送一个消息$m$，他知道Alice产生的 $(N,e)$。他使用起先与Alice约好的格式将$m$转换为一个小于$N$的非负整数，比如他可以将每一个字转换为这个字的Unicode码，然后将这些数字连在一起组成一个数字。假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为$n$。用下面这个公式他可以将$n$加密为$c$：$c\equiv n^e (mod  N)$。计算$c$并不复杂。Bob算出$c$后就可以将它传递给Alice。

- 解密消息
    Alice得到Bob的消息$c$后就可以利用她的密钥$d$来解码。她可以用以下这个公式来将$c$转换为$n$：$n\equiv c^d (mod  N)$, 得到$n$后，她可以将原来的信息$m$重新复原。

    解码的原理是
    $c^d\equiv n^{ed} (mod  N)$

    已知$ed\equiv 1 (mod  r)$，即$ed=1 +h\varphi(N)$。 由欧拉定理得：
    $n^{ed}=n^{1 +h\varphi(N)}=n(n^{\varphi(N)})^h \equiv n(1)^h (mod N) \equiv n (mod N)$


- 安全：
    假设偷听者Eve获得了Alice的公钥$(N,e)$以及Bob的加密消息$c$，但她无法直接获得Alice的密钥$d$。要获得$d$，最简单的方法是将$N$分解为$p$和$q$，这样她可以得到同余方程$de=1(mod(p-1)(q-1))$并解出$d$，然后代入解密公式 $c^d \equiv n (mod  N)$导出 $n$。但至今为止还没有人找到一个多项式时间的算法来分解一个大的整数的因子，同时也还没有人能够证明这种算法不存在。

    至今为止也没有人能够证明对$N$进行因数分解是唯一的从$c$导出$n$的方法，直到今天也还没有找到比它更简单的方法。（至少没有公开的方法。）

    因此今天一般认为只要$N$足够大，那么黑客就没有办法了。

    假如$N$的长度小于或等于256位，那么用一台个人电脑在几个小时内就可以分解它的因子了。1999年，数百台电脑合作分解了一个512位长的$N$。目前推荐的长度至少为2048位。

## 3.2 混合密码


![img]({{ site.url }}/assets/img/source/crypto_12.jpg)



## 3.3迪菲-赫尔曼密钥交换协议

迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为D-H） 是一种安全协议。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。

![img]({{ site.url }}/assets/img/source/crypto_13.jpg)



以下是一个更为一般的描述:

- Alice和Bob协商一个有限循环群 $G$ 和它的一个生成元 $g$。 （这通常在协议开始很久以前就已经规定好； $g$是公开的，并可以被所有的攻击者看到。）
- Alice选择一个随机自然数 $a$ 并且将$g^a mod p$发送给Bob。
- Bob选择一个随机自然数 $b$ 并且将$g^b mod p$发送给Alice。
- Alice 计算$(g^b)^a mod p$。
- Bob 计算$(g^a)^b mod p$ 。


原理：有限循环群上的乘法交换律

为了使这个例子变得安全，必须使用非常大的$a$, $b$ 以及 $p$， 否则会被暴力破解

如果 $p$ 是一个至少 300 位的质数，并且$a$和$b$至少有100位长， 那么即使使用全人类所有的计算资源和当今最好的算法也不可能从$g$, $p$和$g^a mod p$ 中计算出 $a$。这个问题就是著名的**离散对数问题**。注意g则不需要很大, 并且在一般的实践中通常是2或者5。


安全性

在选择了合适的$G$和$g$时，这个协议被认为是窃听安全的。偷听者可能必须通过求解迪菲－赫尔曼问题来得到gab。在当前，这被认为是一个困难问题。如果出现了一个高效的解决离散对数问题的算法，那么可以用它来简化a或者b的计算，那么也就可以用来解决迪菲－赫尔曼问题，使得包括本系统在内的很多公钥密码学系统变得不安全。



# 4.拓展

## 4.1 AES与RSA对比


![img]({{ site.url }}/assets/img/source/crypto_14.jpg)


对称加密的速度是非对称的数百倍

## 4.2 RSA 的密码劣化

![img]({{ site.url }}/assets/img/source/crypto_15.jpg)






